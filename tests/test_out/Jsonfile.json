{
  "title": "A Prototype Implementation of an Orthographic Software Modeling Environment",
  "abstract": "Orthographic Software Modeling (OSM) is a view-centric software engineering approach that aims to leverage the orthographic projection metaphor used in the visualization of physical objects to visualize software systems. Although the general concept of OSM does not prescribe specific sets of views, a concrete OSM environment has to be specific about the particular views to be used in a particular project. At the University of Mannheim we are developing a prototype OSM environment, nAOMi, that supports the views defined by the KobrA 2.0 method, a version of KobrA adapted for OSM. In this paper we provide an overview of the KobrA 2.0 metamodel underpinning nAOMi and give a small example of its use to model a software system.",
  "authors": [],
  "keywords": [
    "D.1.7 [Programming Techniques]: Visual Programming",
    "D.2.2 [Design Tools and Techniques]: Computer-aided software engineering (CASE)",
    "D.2.6 [Software Engineering]: Programming Environments-Graphical environments Orthographic Software Modeling, View-based Modeling KobrA2::SUM::Constraint::Behavioral KobrA2::SUM::Constraint::Structural KobrA2::SUM::Constraint KobrA2::SUM::Constraint::Common KobrA2::SUM::Behavior::ProtocolStateMachines KobrA2::SUM::Behavior::Common KobrA2::SUM::Behavior::Activities KobrA2::SUM::Behavior::Actions KobrA2::SUM::Behavior KobrA2::SUM::Structure::Classes KobrA2::SUM::Structure::Types KobrA2::SUM::Structure::Instances KobrA2::SUM::Structure::Elements KobrA2::SUM::Structure KobrA2::SUM::Constraint::OclExpressions"
  ],
  "references": [
    "Orthographic Software Modeling: A Practical Approach to View-Based Development",
    "Orthographic Service Modeling",
    "Realizing Correspondences in MultiViewpoint Specifications",
    "An effective layout adaptation technique for a graphical modeling tool"
  ],
  "full_text": "Orthographic Software Modeling (OSM) is based on three fundamental hypotheses -(a) that it is feasible to integrate the many different kinds of artifacts used in contemporary software engineering methods within a single coherent methodology in which they are treated as views, (b) that it is feasible to create an efficient and scalable way of supporting these views by generating them dynamically, on-the-fly, from a Single Underlying Model (SUM) using model-based transformations and (c) that it is feasible to provide an intuitive metaphor for navigating around these many views by adapting the orthographic projection technique underpinning the CAD tools used in other engineering disciplines. As shown in Figure  As shown in Figure  To explore the validity of these hypotheses at the University of Mannheim we have been developing a prototype OSM modeling environment based on an enhanced version of the KobrA method for model-driven, component-oriented development, KobrA 2.0  nAOMi is implemented as an Eclipse plugin using the Eclipse Modeling Framework (EMF) as the underlying modeling platform and UML 2.0 tools  The unique contribution of this paper is to elaborate on the structure of the KobrA 2.0 metamodel and how it is used to drive nAOMi. The three following sections each focus on one of the three main components of the metamodel -the SUM, the views and the transformations . This is followed by a brief overview of the OSM navigation paradigm in Section 5 before a small example of the approach is presented in Section 6. Section 7 then concludes the paper with related and future work. Figure  The Classes subpackage of the Structure package contains some of the most fundamental elements of the KobrA metamodel, such as Class and ComponentClass. The internal structure of this package is illustrated in Figure  ComponentClass inherits (indirectly via Class) from Communications so it also has the isActive attribute. This makes it possible to model whether its instances are active or passive. Active objects, which can be used to model threads and processes  A ComponentClass may exhibit complex behavior. In Ko-brA, this behavior may be specified in the form of UML State Diagrams (defining acceptable operation invocation sequences), and in the form of Activities (defining algorithms of operations). UML Interaction elements (in sequence diagrams) can be derived from the activity elements and thus are not included in the SUM. As KobrA aims to facilitate automatic checking of allowed sequences of operation calls, Protocol State Machines are supported instead of general state machines. Since the latter include a large variety of elements not needed for specifying acceptable operation se-quences or automatic checking, OCL constraints are used to prohibit the use of unwanted features. For example, since KobrA has no concept of roles for components, the use of role also needs to be prohibited. The part association refers to owned properties of components whose attribute isComposite is true. As KobrA uses associations like nests and creates for components, part, required and provided are not needed. Connectors (i.e. delegation and assembly) are not used in KobrA either so ownedConnector is excluded.   The structure of the Views package is illustrated in Figure  The substructure of the Views package reflects the types and organization of the KobrA views according to the view \"dimensions\" supported in nAOMi (cf. example in  The Service view shows the direct, publicly visible relationships of the subject ComponentClass to other Compo-nentClasses, while the Type view shows the publicly visible relationships of the subject to simple Classes. As with the SUM, constraints have been defined to control what can go into each view and when they are well formed. For every view, a constraint enumerates all allowed elements (not shown in this paper). In the following, some of the other constraints for the Service view are elaborated. Since this view is a black-box view, the internals of ComponentClasses (nestedClassifier ) are not shown. context ComponentClass --no nested classifiers , no protocol inv : nestedClassifier -> union ( protocol ) -> isEmpty () Classes are only allowed if they are generalizations of Com-ponentClasses, (or any of its superclasses, since a Compo-nentClass may inherit from a class as shown in the constraints with context Class. The following invariants ensure that only publicly visible attributes and operations are in this view, for both classes and ComponentClasses (which inherit from Class). Only operation signatures are shown in this view, so pre-, post-and bodyconditions, as well as activities are omitted, which is reflected in the last constraint. context Operation --only the signature of the Operation is shown , not its behavior ( role name \" method \" refers to the Activities of the operation ) , or dependencies inv : method -> union ( precondition ) -> union ( body ) -> union ( postcondition ) -> isEmpty () The package AllViews provides the foundation for specifying the transformations between the SUM and the views in both directions. Part of the package's contents are shown in Figure  In the case of KobrA 2.0, which has many projections that just select a subset of elements using one-to-one abstractions, this allows concise declarative TransformationExpressions. Together with the view constraints, a CASE tool can be implemented which uses a transformation language of the implementor's choice, for instance the Atlas Transformation Language (ATL)  The following transformation rules illustrate how to create the output (i.e. view) elements from the input (i.e. SUM) elements, such as the publicly visible attributes and operations of the ComponentClass and the acquired ComponentClasses. The first constraint for ComponentClassAbstraction states that references to potential general classes (and Component-Classes) of ComponentClasses are mirrored in the view. In addition, ComponentClasses will be shown with the corresponding stereotypes. The ComponentClass owns various types of associations, so in this view only the acquires associations are selected (whose transformation rules are covered in the common transformation packages).For classes and ComponentClasses, only publicly visible attributes and operations appear in the view. Class invariants are also copied. Classes that may appear in this view (e.g. as generalizations of ComponentClasses) may have a powertype (role name powertypeExtent) which will be displayed. The last transformation statement copies the class references of operations. As with all views, the transformation rules, the common transformation statements (which also cover operations) and the view constraints serve as a specification for the implementation of a view. Individual CASE tools can use different implementation techniques as long as they conform to the semantics of these rules and constraints.  For the black box type view, only publicly visible attributes and operations of classes (as opposed to Compo-nentClasses) used by the subject can be seen. This is specified in the first rule which defines owned members of the view and thus serves as the starting point of the transformation. cbbTypes is a utility function defined in the SUM which computes the black box types by selecting the types of the subject's public attributes and parameter types of its public operations. Class invariants and potential powertypes and connections to the classes in this view are shown as well. There may also be Enumerations, for which the EnumerationLiterals are displayed. The transformation rules for this view are almost the same as the realization transformation constraints from the package Transformation::Realization::Structural::Class::Type. The differences are the select(visibility=#public) statements for operations and attributes. s t r i n g I n S i g n a t u r e Most of today's tools use some combination of trees to organize the content of models as well as the views used to visualize a software system or component. In an any environment incorporating a number of different tools there is invariably a large number of different trees storing a heterogeneous mix of artifacts including model elements (e.g. classes, instances, associations), diagrams (e.g. class diagrams, state diagrams) and other artifact types (source code, XML files, configuration files ). To work with all the views in a traditional development environment, therefore, engineers typically have to learn about the organization structures of all the incorporated tools. In contrast to conventional paradigms for organizing and navigating the many views used to visualize a system, OSM employs the metaphor of a multi-dimensional cube. More specifically, as illustrated in Figure  To support the OSM dimension based navigation metaphor for KobrA, we defined the seven dimensions indicated on the left hand side of Figure  The Encapsulation dimension, which has two fixed elements, supports the distinction between Specification (black box) and Realization (white box) views of components, while the Projection dimension with the fixed elements Structural, Operational and Behavioral covers the different information types. The Granularity dimension provides a finer grained distinction between views describing the types used by components (Type granularity) and views describing the required and provided interfaces (Service granularity). The Operation dimension allows a selection of individual operations. In the ideal case, when all views are truly orthogonal, the choices that can be made in each dimensions are completely independent. However, this is very difficult to achieve in software engineering. The approach still works if the views are not completely orthogonal, but dependencies then occur between different choices in different dimensions, so that the decisions made in one dimensions may affect choices possible in another dimension. This is best handled by giving dimensions a precedence ranking determined by the order in which they appear (the top being the highest). When an element in a dimension is selected, the tool automatically makes default selections for dimensions of lower precedence (i.e. dimensions lower down) and disables selections that would navigate to cells (i.e. views) which are not (yet) defined by the method at hand. To show how a software system can be specified using nAOMi, this section presents a case study based on a shopping cart system. A ShoppingCart component collects and manages the products selected by users and supports payment via a credit card. Figure  In the dimension navigator on the left hand side, PIM was chosen for the \"Abstraction Level\" (not expanded in the screenshot). The second dimension is the state of the software system at a certain point in time. The picture shows that the latest available version was chosen. As with every choice in a dimension, it may influence the options in lower ranked dimensions. The component under consideration is the ShoppingCart, for which a black box view is selected in the next dimension. After the user selects the structural projection option and the service level granularity, the tool automatically chooses the option for all operations in the last dimension, as there is no editor registered for the other options. The component under development is presented with the stereotype subject and its relationship to other components and classes is shown in the view, which corresponds to a cell of the multi-dimensional navigation cube, and is generated on-the-fly from the SUM when it is selected. The classes Product and CreditCard can be used as data types in the operations of the component. Figure  Figure  At the beginning of the paper we identified three fundamental hypothesis upon which the notion of OSM is based -(a) that it is feasible to integrate the many different kinds of artifacts used in contemporary software engineering methods within a single coherent methodology in which they are treated as views, (b) that it is feasible to create an efficient and scalable way of supporting these views by generating them dynamically, on-the-fly, from a Single Underlying Model (SUM) using model-based transformations and (c) that it is feasible to provide an intuitive metaphor for navigating around these many views by adapting the orthographic projection technique underpinning the CAD tools used in other engineering disciplines. The prototype tool, nAOMi, described in this paper represents the first step towards demonstrating the validity of these hypotheses and showing that OSM is a viable approach to software engineering. Of the three hypotheses, (a) and (c) are most convincingly demonstrated by the prototype, since it shows that it is indeed possible to support all the views of the KobrA method within a single navigation metaphor. The prototype tool does not demonstrate the validity of hypothesis (b) to the same extent as the others due to its small size. Although it demonstrates the feasibility of generating views from the SUM and vice-versa, the question of whether such an approach scales up to large environments is still open. Although nOAMi is the only tool developed with the specific aim of supporting KobrA-based OSM, several other tools and methods have similar properties or aims. For example, Glinz et al.  An approach which also emphasizes the description of formal consistency rules (correspondences) between views is RM-ODP  Regarding the practical use of OSM environments in the future, the biggest challenge is developing appropriate SUM metamodels which can accommodate all the types of views and services that software engineers are accustomed to today. For this first prototypical SUM-based environment supporting the OSM approach we had a method at our disposal (KobrA) that already defined a full set of orthogonal UMLbased views. This allowed us to model the required SUM and view metamodels by simply adapting the UML metamodels, removing and adding model elements as needed. In doing so we were able to manually ensure that the metamodels fulfilled the two core requirements of SUM-based environments -(1) being minimalistic and (2) redundancy free. If SUM-based software engineering environments are to take off, and to be introduced into existing, heterogeneous environments, more sophisticated ways of integrating existing metamodels into a single unified metamodel will be required."
}